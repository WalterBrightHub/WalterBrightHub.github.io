{"meta":{"title":"布洛格","subtitle":"你他妈少在这里妖言惑众","description":null,"author":"水明","url":"https://walterbright.cc","root":"/"},"pages":[{"title":"404","date":"2019-03-26T17:37:44.527Z","updated":"2019-03-26T17:37:44.527Z","comments":true,"path":"404.html","permalink":"https://walterbright.cc/404.html","excerpt":"","text":"这里什么也没有喔"},{"title":"关于我","date":"2019-03-25T12:14:50.288Z","updated":"2019-03-25T12:14:50.288Z","comments":true,"path":"about/index.html","permalink":"https://walterbright.cc/about/index.html","excerpt":"","text":"一名学生，主攻前端，目前就读于浙江工业大学。"},{"title":"所有分类","date":"2019-03-25T10:15:39.661Z","updated":"2019-03-25T10:15:39.661Z","comments":true,"path":"categories/index.html","permalink":"https://walterbright.cc/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-03-25T11:24:29.930Z","updated":"2019-03-25T11:24:29.930Z","comments":true,"path":"friends/index.html","permalink":"https://walterbright.cc/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-03-25T13:07:34.543Z","updated":"2019-03-25T13:07:34.543Z","comments":true,"path":"tags/index.html","permalink":"https://walterbright.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小胖的二十四点","slug":"24-game","date":"2019-03-26T16:20:18.000Z","updated":"2019-03-26T17:26:03.659Z","comments":true,"path":"2019-03/24-game/","link":"","permalink":"https://walterbright.cc/2019-03/24-game/","excerpt":"问题描述给定四个数，四个基本运算符+,-,*,/，计算二十四点。可以添加括号。","text":"问题描述给定四个数，四个基本运算符+,-,*,/，计算二十四点。可以添加括号。 分析对于具体的一组形如a op1 b op2 c op3 d的算式，其添加括号就相当于指定三个操作符的顺序。例如，(a op1 b) op2 (c op3 d)可看成先执行op1、op3再执行op2。故理论上遍历4!种数字排列*(4*4*4)种操作符排列*3!种操作符调用顺序即可，实际代码中优化避免重复计算。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239const cal=(a,op,b)=&gt;&#123; if(op==='+')&#123; return &#123; val:a.val+b.val, exp:`($&#123;a.exp&#125;$&#123;op&#125;$&#123;b.exp&#125;)` &#125; &#125; else if(op==='-')&#123; return &#123; val:a.val-b.val, exp:`($&#123;a.exp&#125;$&#123;op&#125;$&#123;b.exp&#125;)` &#125; &#125; else if(op==='*')&#123; return &#123; val:a.val*b.val, exp:`($&#123;a.exp&#125;$&#123;op&#125;$&#123;b.exp&#125;)` &#125; &#125; else if(op==='/')&#123; return &#123; val:a.val/b.val, exp:`($&#123;a.exp&#125;$&#123;op&#125;$&#123;b.exp&#125;)` &#125; &#125; else&#123; throw new Error('unknow op') &#125;&#125;const schemeFrom=(a,opi,b,opj,c,opk,d)=&gt;mode=&gt;&#123; if(mode===123)&#123; return cal(cal(cal(a,opi,b),opj,c),opk,d) &#125; else if(mode===132)&#123; return cal(cal(a,opi,b),opj,cal(c,opk,d)) &#125; else if(mode===213)&#123; return cal(cal(a,opi,cal(b,opj,c)),opk,d) &#125; else if(mode===231)&#123; return cal(a,opi,cal(cal(b,opj,c),opk,d)) &#125; else if(mode===312)&#123; return cal(cal(a,opi,b),opj,cal(c,opk,d)) &#125; else if(mode===321)&#123; return cal(a,opi,cal(b,opj,cal(c,opk,d))) &#125; else&#123; throw new Error('unknow mode') &#125;&#125;const isAddOrSub=op=&gt;op==='+'||op==='-'const mode=(opi,opj,opk)=&gt;&#123; let i=isAddOrSub(opi)?0:1 let j=isAddOrSub(opj)?0:1 let k=isAddOrSub(opk)?0:1 return [i,j,k].join('')&#125;const mathEqual=(a,b)=&gt;Math.abs(a-b)&lt;1e-10const solve=target=&gt;&#123; return function*(a,b,c,d)&#123; const ops=['+','-','*','/'] for(let i=0;i&lt;4;i++)&#123; for(let j=0;j&lt;4;j++)&#123; for(let k=0;k&lt;4;k++)&#123; let opi=ops[i] let opj=ops[j] let opk=ops[k] let md=mode(opi,opj,opk) let scheme let schemeBy=schemeFrom(&#123; val:a, exp:a.toString() &#125;, opi,&#123; val:b, exp:b.toString() &#125;, opj,&#123; val:c, exp:c.toString() &#125;, opk,&#123; val:d, exp:d.toString() &#125;) if(md==='001'||md==='110')&#123; scheme=schemeBy(123) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; scheme=schemeBy(132) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; scheme=schemeBy(231) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; &#125; else if(md==='010'||md==='101')&#123; scheme=schemeBy(123) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; scheme=schemeBy(132) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; scheme=schemeBy(213) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; scheme=schemeBy(321) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; &#125; else if(md==='100'||md==='011')&#123; scheme=schemeBy(123) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; scheme=schemeBy(213) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; scheme=schemeBy(231) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; &#125; else if(md==='111'||md==='000')&#123; scheme=schemeBy(123) if(mathEqual(scheme.val,target))&#123; yield scheme &#125; &#125; else&#123; throw Error('unknow mode') &#125; &#125; &#125; &#125; &#125;&#125;const solveOneOrder=target=&gt;(a,b,c,d)=&gt;&#123; const schemeGenerator=solve(target)(a,b,c,d) const one=schemeGenerator.next() return one.done?-1:one.value&#125;const solveAllOrder=target=&gt;(a,b,c,d)=&gt;&#123; const schemeGenerator=solve(target)(a,b,c,d) const schemes=[] for(let scheme of schemeGenerator)&#123; schemes.push(scheme) &#125; return schemes&#125;const next_perm=arr=&gt;&#123; if(arr.length===1)&#123; return false &#125; else&#123; let cp=arr.slice() let l=cp.length-2 while(l &amp;&amp; cp[l]&gt;=cp[l+1])&#123; l-- &#125; if(cp[l]&gt;=cp[l+1])&#123; return false &#125; else&#123; let r=l+1 while(cp[r+1]&gt;cp[l])&#123; r++ &#125; let t=cp[l] cp[l]=cp[r] cp[r]=t let tail=cp.splice(l+1).reverse() cp=cp.concat(tail) &#125; return cp &#125; &#125;const perm=arr=&gt;&#123; let curr=arr.slice().sort((a,b)=&gt;a-b) let ret=[] while(curr)&#123; ret.push(curr) curr=next_perm(curr) &#125; return ret&#125;const solveOneGenerator=target=&gt;function*(a,b,c,d)&#123; const perms=perm([a,b,c,d]) for(let currPerm of perms)&#123; const currScheme=solveOneOrder(target)(...currPerm) if(currScheme)&#123; yield currScheme &#125; &#125;&#125;const solveOne=target=&gt;(a,b,c,d)=&gt;&#123; const schemeGenerator=solveOneGenerator(target)(a,b,c,d) const one=schemeGenerator.next() return one.done?-1:one.value&#125;const solveAll=target=&gt;(a,b,c,d)=&gt;&#123; const perms=perm([a,b,c,d]) const allSchemes=perms.reduce((allS,currPerm)=&gt;&#123; const currScheme=solveAllOrder(target)(...currPerm) return allS.concat(currScheme) &#125;,[]) return allSchemes&#125;console.log(solveOne(24)(11,9,5,7))/*[ &#123; val: 24, exp: '((5+7)*(11-9))' &#125;, &#123; val: 24, exp: '((7+5)*(11-9))' &#125;, &#123; val: 24, exp: '((11-9)*(5+7))' &#125;, &#123; val: 24, exp: '((11-9)*(7+5))' &#125; ]*/","categories":[{"name":"算法","slug":"算法","permalink":"https://walterbright.cc/categories/算法/"},{"name":"思维","slug":"算法/思维","permalink":"https://walterbright.cc/categories/算法/思维/"}],"tags":[{"name":"乱搞","slug":"乱搞","permalink":"https://walterbright.cc/tags/乱搞/"}]},{"title":"小胖的三角形","slug":"traingle","date":"2019-03-26T10:50:10.000Z","updated":"2019-03-26T16:54:10.497Z","comments":true,"path":"2019-03/traingle/","link":"","permalink":"https://walterbright.cc/2019-03/traingle/","excerpt":"问题描述给定若干正数，问其中是否存在三个数可以构成三角形，若存在则输出其周长，否则输出-1。有多组解时求出任一解即可。","text":"问题描述给定若干正数，问其中是否存在三个数可以构成三角形，若存在则输出其周长，否则输出-1。有多组解时求出任一解即可。 分析若暴力循环则复杂度为$O(n^3)$ 猜想将数组排序，若存在连续的三个数可以构成三角形，则返回这三个数的和，否则返回-1。这样算法复杂度为$O(\\log n+n)$。 证明：只需证明若排序后不存在连续的三个数可以构成三角形，则不存在任意三个数可以构成三角形。这是显然的。","categories":[{"name":"算法","slug":"算法","permalink":"https://walterbright.cc/categories/算法/"},{"name":"思维","slug":"算法/思维","permalink":"https://walterbright.cc/categories/算法/思维/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://walterbright.cc/tags/思维/"}]},{"title":"《ES6函数式编程入门经典》读书笔记","slug":"beginning-functional-javascript","date":"2019-03-16T17:43:55.000Z","updated":"2019-03-26T17:41:11.368Z","comments":true,"path":"2019-03/beginning-functional-javascript/","link":"","permalink":"https://walterbright.cc/2019-03/beginning-functional-javascript/","excerpt":"初入函数式编程的坑，试试这本书吧。","text":"初入函数式编程的坑，试试这本书吧。 函数式编程简介概念函数的概念。函数是通过其名字调用的代码，它可以传递参数并返回值。函数式编程主张至少接受一个参数，并且返回一个值。和方法的区别：方法是通过其名称与关联的对象来调用。 函数的两个特性 引用透明性。函数对相同的输入总有相同的输出。好处是并发编程、可缓存代码（如阶乘）。 声明式编程。与命令式编程不同，函数式编程主张以抽象的方式创建函数。 函数式编程的好处 纯函数。纯函数使得代码易于阅读、理解、测试。 并发代码。无需担心同步问题。 编写可缓存、可记忆的函数。 管道与（函数式）组合。组合是函数式编程范式的核心。 纯函数是数学函数，可以将数学思想引入编程思想。 JavaScript函数基础书中的Node还不支持ES6，故用babel编译运行。如今Node已经支持ES6，直接运行JS文件即可。 forEach(array,fn) 对数组的每一个元素调用fn 高阶函数理解数据JavaScript数据类型 Number String Boolean Object null undefined 函数是一等公民，可以赋值给变量、作为函数参数、作为函数返回值。 抽象和高阶函数抽象：隐藏实现细节，专注于实现，降低复杂度。高阶函数实现抽象 forEach(array,fn) forEachObject(object,fn) unless(predicate,fn) times(times,fn) every(array,fn) some(array,fn) sort 闭包与高阶函数闭包函数闭包是一个函数内部的另一个函数。它有三个可访问作用域： 本身内声明的变量 全局变量 外部函数定义的变量 使用闭包构建高阶函数： tap接受一个value，返回一个包含value的闭包函数。 unary类似于适配器模式。 once只执行一次给定的函数。 memoized 数组的函数式编程投影函数 map filter 连接函数连接map和filter，最简单的方法是直接嵌套。concatAll是一个辅助函数，辅助函数之间的连接。 concatAll(array,fn)将嵌套（一层的）数组转化为非嵌套的单一数组。 reduce reduce(array,fn,initValue)将数组归约成一个单一的值。 实现 12345678910111213141516const reduce=(array,fn,indexValue)=&gt;&#123; if(indexValue)&#123; let result=indexValue for(let i=0;i&lt;array.length;i++)&#123; result=fn(result,array[i]) &#125; return result &#125; else&#123; let result=array[0] for(let i=1;i&lt;array.length;i++)&#123; result=fn(result,array[i]) &#125; return result &#125;&#125;; zip zip(leftArr,rightArr,fn) 柯里化与偏应用预备知识：一元函数、二元函数、变参函数。 概念：柯里化是将一个多参函数转化为嵌套的一元函数的过程。 1234567891011121314151617181920const curry=fn=&gt;&#123; if(typeof fn !=='function')&#123; throw new Error('no function provided') &#125; else&#123; return function curriedFn(...args)&#123; if(args.length&lt;fn.length)&#123; console.log(args) return function()&#123; console.log(arguments) return curriedFn.apply(null,args.concat([].slice.call(arguments))) &#125; &#125; else&#123; console.log(args) return fn.apply(null,args) &#125; &#125; &#125;&#125; 实例 123let add=(a,b,c)=&gt;a+b+clet curriedAdd=curry(add)curry(add)(3)(7)(5) 偏函数偏函数用于创建创建可重用的函数，而不需要自己写包装器。 12345678910111213141516const partial=(fn,...partialArgs)=&gt;&#123; let args=partialArgs return (...fullArguments)=&gt;&#123; let arg=0 let fullArgs=[] for(let i=0;i&lt;args.length &amp;&amp; arg&lt;fullArguments.length;i++)&#123; if(args[i]===undefined)&#123; fullArgs.push(fullArguments[arg++]) &#125; else&#123; fullArgs.push(args[i]) &#125; &#125; return fn.apply(null,fullArgs) &#125;&#125; 实例 123456789101112//不需要每次写这样的包装器了//let ugly=fn=&gt;setTimeout(fn,10)let delayTenMs=partial(setTimeout,undefined,10)delayTenMs(()=&gt;&#123; console.log('hello world')&#125;)delayTenMs(()=&gt;&#123; console.log('goodbyle world')&#125;) 组合与管道组合概念：以一个函数的输出作为另一个函数的输入的方式，将多个函数结合起来。 compose compose(…fns)组合多个函数，数据流是从右至左的。 pipe(…fns)数据流是从左至右的，管道pipeline也可以称作序列sequence。实现上两者只有很小的不同。 实现 123456const compose=(...fns)=&gt; (value)=&gt; reduce(fns.reverse(),(acc,fn)=&gt;fn(acc),value)const pipe=(...fns)=&gt; (value)=&gt; reduce(fns,(acc,fn)=&gt;fn(acc),value) 如何组合多参函数？使用柯里化和偏应用即可。实例 12345678let add=(x,y)=&gt;x+ylet div=(x,y)=&gt;x/ylet ac=compose(curry(div)(50),curry(add)(4))// 50/(4+x)console.log(ac(3)) 组合的优势组合符合结合律。 组合的应用方便地log。创建identity函数，在数据流中随意的插入或移除，方便调试。 1234const identity=(it)=&gt;&#123; console.log(it) return it&#125; 函子函子是一个对象或者类，它实现了map函数，在遍历每个对象值的时候生成新的对象。简单的说，函子是一个包含值的容器，并且实现了map函数。实现 12345678910111213class Container&#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Container(value) &#125; map(fn)&#123; return Container.of(fn(this.value)) &#125;&#125; Maybe该函子会检查传入的值是否为null或者undefined，如果是则什么也不做。该函子用于错误处理。实现 1234567891011121314151617class Maybe &#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Maybe(value) &#125; isNothing()&#123; return this.value===null || this.value===undefined &#125; map(fn)&#123; return this.isNothing()?Maybe.of(null):Maybe.of(fn(this.value)) &#125;&#125; EitherEither用于解决分支拓展问题。 1234567891011121314151617181920212223242526272829303132class Nothing&#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Nothing(value) &#125; map()&#123; return this &#125;&#125;class Some&#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Some(value) &#125; map(fn)&#123; return Some.of(fn(this.value)) &#125;&#125;const Either=&#123; Nothing:Nothing, Some:Some&#125; 使用Either 1234567891011121314151617181920let summary=data=&gt;data.reduce((sum,val)=&gt;sum+val,0)let cal=data=&gt;&#123; let sum try&#123; sum=Either.Some.of(summary(data)) &#125; catch(e)&#123; sum=Either.Nothing.of(&#123; msg:'something has wrong.' &#125;) &#125; return sum&#125;console.log(cal(5))//Nothing &#123; value: &#123; msg: 'something has wrong.' &#125; &#125;console.log(cal([5]))//Some &#123; value: 5 &#125; MonadMonad是一个实现chain方法的函子。join方法返回函子包含的值。chain方法包装了map和join方法。实现 12345678910111213141516171819202122232425class Maybe &#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Maybe(value) &#125; isNothing()&#123; return this.value===null || this.value===undefined &#125; join()&#123; return this.isNothing()?Maybe.of(null):this.value &#125; chain(fn)&#123; return this.map(fn).join() &#125; map(fn)&#123; return this.isNothing()?Maybe.of(null):Maybe.of(fn(this.value)) &#125;&#125; 使用（书上的示例太复杂，写个简单的） 1234567891011121314151617181920212223242526272829303132333435363738394041let bro=Maybe.of(&#123; name:'xhb', age:5&#125;)//我们来模仿一个场景！首先我们给小熊加一岁。let newBro=bro.map(bear=&gt;&#123; return &#123; ...bear, age:bear.age+1 &#125;&#125;)//我们继续处理小熊。//为了方便，我们直接输出小熊。newBro.map(bear=&gt;&#123; console.log(bear)&#125;)//天啊！这样太麻烦了。为了输出小熊我们不得不调用map函数。//关键是，此刻我们关心的是bear，而不是包装了bear的Maybe//可以这样let bigBear=bro.map(bear=&gt;&#123; return &#123; ...bear, age:bear.age+2 &#125;&#125;).join()console.log(bigBear)//顺利取出了结果！//每次都要写map和join，不如封装到一起let biggerBear=bro.chain(bear=&gt;&#123; return &#123; ...bear, age:bear.age+3 &#125;&#125;)console.log(biggerBear)//真好","categories":[{"name":"编程范式","slug":"编程范式","permalink":"https://walterbright.cc/categories/编程范式/"},{"name":"函数式编程","slug":"编程范式/函数式编程","permalink":"https://walterbright.cc/categories/编程范式/函数式编程/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://walterbright.cc/tags/函数式编程/"},{"name":"入门","slug":"入门","permalink":"https://walterbright.cc/tags/入门/"}]}]}