{"meta":{"title":"布洛格","subtitle":"你他妈少在这里妖言惑众","description":null,"author":"水明","url":"https://walterbright.cc","root":"/"},"pages":[{"title":"所有分类","date":"2019-03-25T10:15:39.661Z","updated":"2019-03-25T10:15:39.661Z","comments":true,"path":"categories/index.html","permalink":"https://walterbright.cc/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-03-25T12:14:50.288Z","updated":"2019-03-25T12:14:50.288Z","comments":true,"path":"about/index.html","permalink":"https://walterbright.cc/about/index.html","excerpt":"","text":"一名学生，主攻前端，目前就读于浙江工业大学。"},{"title":"","date":"2019-03-25T10:09:54.601Z","updated":"2019-03-25T10:09:54.601Z","comments":true,"path":"pages/music.html","permalink":"https://walterbright.cc/pages/music.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-03-25T10:21:09.936Z","updated":"2019-03-25T10:21:09.936Z","comments":true,"path":"tags/index.html","permalink":"https://walterbright.cc/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-03-25T11:24:29.930Z","updated":"2019-03-25T11:24:29.930Z","comments":true,"path":"friends/index.html","permalink":"https://walterbright.cc/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Lodash API归档","slug":"lodash-api","date":"2019-03-25T06:34:29.000Z","updated":"2019-03-25T10:47:56.966Z","comments":true,"path":"2019-03/lodash-api/","link":"","permalink":"https://walterbright.cc/2019-03/lodash-api/","excerpt":"根据函数签名归档的Lodash API（v4.17.11）。","text":"根据函数签名归档的Lodash API（v4.17.11）。方法如无特别说明则不改变原集合。 Arrayarray -&gt; array(array)_.chunk按步长分割数组。 array -&gt; array_.compact筛除数组中的false,null,0,’’,undefined,NAN。 drop筛除头部n个元素，默认n=1 dropWhile从头部开始筛除元素，直到条件不满足。 dropRight筛除尾部n个元素，默认n=1 dropRightWhile从尾部开始筛除元素，直到条件不满足。 _.flatten,_.flattenDeep,_.flattenDepth扁平处理一层；递归扁平处理;扁平处理时指定层数。 _.initial筛除最后一个元素 _.tail筛除第一个元素 _.slice截取数组。默认拷贝完整数组。 _.take截取数组中开始的n个元素，默认n=1。 _.takeWhile从开头往后截取元素，直到条件不满足。 _.takeRight截取数组中倒数的n个元素，默认n=1。 _.takeRightWhile从末尾往前截取元素，直到条件不满足。 _.uniq,_.uniqBy,_.uniqWith数组去重。 _.sortedUniq,_.sortedUniqBy为排好序的数组优化的去重函数。 _.without筛除与指定元素相同的元素。 …array -&gt; array_.concat连接数组。 _.difference,_.differenceBy,_.differenceWith筛除第一个数组中，同时存在于其余任一数组的元素。 _.intersection,_.intersectionBy,_.intersectionWtih筛选第一个数组中，同时存在于其余所有数组的元素。 _.union,_.unionBy,_.unionWith合并数组并去重。 _.xor,xorBy,xorWith获取集合的对称差。 array(…array) -&gt; array(…array)_.zip,zipWith组合多个数组。 _.unzip,_.unzipWith解组数组。 array(array,array) -&gt; object_.zipObject输入键数组和值数组，返回对象。 _.zipObjectDeep输入键（支持路径）数组和值数组，返回对象。 array -&gt; number_.findIndex,_.findLastIndex _.indexOf _.lastIndexOf _.sortedIndex,_.sortedIndexBy数组必须升序排列。返回二叉搜索value插入的下标的最小值。 _.sortedLastIndex,_.sortedLastIndexOf数组必须升序排列。返回二叉搜索value插入的下标的最大值。 _.sortedIndexOf返回升序数组中第一个出现的value的下标。 array -&gt; element_.head获取数组第一个元素。 _.last获取数组中最后一个元素。 _.nth获取数组中下标为n的元素，n默认为0。 array -&gt; string_.join连接数组元素，默认分隔符为, pairs -&gt; object_.fromPairs从包含键值对的数组构建对象。 object -&gt; pairs_.toPairs解构对象成包含键值对的数组。 array -&gt; array 改变原数组_.fill填充数组，可指定起始点 _.pull,_.pullAll,_.pullAllBy,_.pullAllWith移除与指定元素相同的元素。 _.pullAt移除指定下标的元素。返回被移除的元素。 _.remove依据指定的规则移除元素。返回被移除的元素。 _.reverse反转数组。","categories":[],"tags":[{"name":"Lodash","slug":"Lodash","permalink":"https://walterbright.cc/tags/Lodash/"}]},{"title":"《ES6函数式编程入门经典》读书笔记","slug":"beginning-functional-javascript","date":"2019-03-16T17:43:55.000Z","updated":"2019-03-25T12:10:23.821Z","comments":true,"path":"2019-03/beginning-functional-javascript/","link":"","permalink":"https://walterbright.cc/2019-03/beginning-functional-javascript/","excerpt":"初入函数式编程的坑，试试这本书吧。","text":"初入函数式编程的坑，试试这本书吧。 函数式编程简介概念函数的概念。函数是通过其名字调用的代码，它可以传递参数并返回值。函数式编程主张至少接受一个参数，并且返回一个值。和方法的区别：方法是通过其名称与关联的对象来调用。 函数的两个特性 引用透明性。函数对相同的输入总有相同的输出。好处是并发编程、可缓存代码（如阶乘）。 声明式编程。与命令式编程不同，函数式编程主张以抽象的方式创建函数。 函数式编程的好处 纯函数。纯函数使得代码易于阅读、理解、测试。 并发代码。无需担心同步问题。 编写可缓存、可记忆的函数。 管道与（函数式）组合。组合是函数式编程范式的核心。 纯函数是数学函数，可以将数学思想引入编程思想。 JavaScript函数基础书中的Node还不支持ES6，故用babel编译运行。如今Node已经支持ES6，直接运行JS文件即可。 forEach(array,fn) 对数组的每一个元素调用fn 高阶函数理解数据JavaScript数据类型 Number String Boolean Object null undefined 函数是一等公民，可以赋值给变量、作为函数参数、作为函数返回值。 抽象和高阶函数抽象：隐藏实现细节，专注于实现，降低复杂度。高阶函数实现抽象 forEach(array,fn) forEachObject(object,fn) unless(predicate,fn) times(times,fn) every(array,fn) some(array,fn) sort 闭包与高阶函数闭包函数闭包是一个函数内部的另一个函数。它有三个可访问作用域： 本身内声明的变量 全局变量 外部函数定义的变量 使用闭包构建高阶函数： tap接受一个value，返回一个包含value的闭包函数。 unary类似于适配器模式。 once只执行一次给定的函数。 memoized 数组的函数式编程投影函数 map filter 连接函数连接map和filter，最简单的方法是直接嵌套。concatAll是一个辅助函数，辅助函数之间的连接。 concatAll(array,fn)将嵌套（一层的）数组转化为非嵌套的单一数组。 reduce reduce(array,fn,initValue)将数组归约成一个单一的值。 实现 12345678910111213141516const reduce=(array,fn,indexValue)=&gt;&#123; if(indexValue)&#123; let result=indexValue for(let i=0;i&lt;array.length;i++)&#123; result=fn(result,array[i]) &#125; return result &#125; else&#123; let result=array[0] for(let i=1;i&lt;array.length;i++)&#123; result=fn(result,array[i]) &#125; return result &#125;&#125;; zip zip(leftArr,rightArr,fn) 柯里化与偏应用预备知识：一元函数、二元函数、变参函数。 概念：柯里化是将一个多参函数转化为嵌套的一元函数的过程。 1234567891011121314151617181920const curry=fn=&gt;&#123; if(typeof fn !=='function')&#123; throw new Error('no function provided') &#125; else&#123; return function curriedFn(...args)&#123; if(args.length&lt;fn.length)&#123; console.log(args) return function()&#123; console.log(arguments) return curriedFn.apply(null,args.concat([].slice.call(arguments))) &#125; &#125; else&#123; console.log(args) return fn.apply(null,args) &#125; &#125; &#125;&#125; 实例 123let add=(a,b,c)=&gt;a+b+clet curriedAdd=curry(add)curry(add)(3)(7)(5) 偏函数偏函数用于创建创建可重用的函数，而不需要自己写包装器。 12345678910111213141516const partial=(fn,...partialArgs)=&gt;&#123; let args=partialArgs return (...fullArguments)=&gt;&#123; let arg=0 let fullArgs=[] for(let i=0;i&lt;args.length &amp;&amp; arg&lt;fullArguments.length;i++)&#123; if(args[i]===undefined)&#123; fullArgs.push(fullArguments[arg++]) &#125; else&#123; fullArgs.push(args[i]) &#125; &#125; return fn.apply(null,fullArgs) &#125;&#125; 实例 123456789101112//不需要每次写这样的包装器了//let ugly=fn=&gt;setTimeout(fn,10)let delayTenMs=partial(setTimeout,undefined,10)delayTenMs(()=&gt;&#123; console.log('hello world')&#125;)delayTenMs(()=&gt;&#123; console.log('goodbyle world')&#125;) 组合与管道组合概念：以一个函数的输出作为另一个函数的输入的方式，将多个函数结合起来。 compose compose(…fns)组合多个函数，数据流是从右至左的。 pipe(…fns)数据流是从左至右的，管道pipeline也可以称作序列sequence。实现上两者只有很小的不同。 实现 123456const compose=(...fns)=&gt; (value)=&gt; reduce(fns.reverse(),(acc,fn)=&gt;fn(acc),value)const pipe=(...fns)=&gt; (value)=&gt; reduce(fns,(acc,fn)=&gt;fn(acc),value) 如何组合多参函数？使用柯里化和偏应用即可。实例 12345678let add=(x,y)=&gt;x+ylet div=(x,y)=&gt;x/ylet ac=compose(curry(div)(50),curry(add)(4))// 50/(4+x)console.log(ac(3)) 组合的优势组合符合结合律。 组合的应用方便地log。创建identity函数，在数据流中随意的插入或移除，方便调试。 1234const identity=(it)=&gt;&#123; console.log(it) return it&#125; 函子函子是一个对象或者类，它实现了map函数，在遍历每个对象值的时候生成新的对象。简单的说，函子是一个包含值的容器，并且实现了map函数。实现 12345678910111213class Container&#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Container(value) &#125; map(fn)&#123; return Container.of(fn(this.value)) &#125;&#125; Maybe该函子会检查传入的值是否为null或者undefined，如果是则什么也不做。该函子用于错误处理。实现 1234567891011121314151617class Maybe &#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Maybe(value) &#125; isNothing()&#123; return this.value===null || this.value===undefined &#125; map(fn)&#123; return this.isNothing()?Maybe.of(null):Maybe.of(fn(this.value)) &#125;&#125; EitherEither用于解决分支拓展问题。 1234567891011121314151617181920212223242526272829303132class Nothing&#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Nothing(value) &#125; map()&#123; return this &#125;&#125;class Some&#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Some(value) &#125; map(fn)&#123; return Some.of(fn(this.value)) &#125;&#125;const Either=&#123; Nothing:Nothing, Some:Some&#125; 使用Either 1234567891011121314151617181920let summary=data=&gt;data.reduce((sum,val)=&gt;sum+val,0)let cal=data=&gt;&#123; let sum try&#123; sum=Either.Some.of(summary(data)) &#125; catch(e)&#123; sum=Either.Nothing.of(&#123; msg:'something has wrong.' &#125;) &#125; return sum&#125;console.log(cal(5))//Nothing &#123; value: &#123; msg: 'something has wrong.' &#125; &#125;console.log(cal([5]))//Some &#123; value: 5 &#125; MonadMonad是一个实现chain方法的函子。join方法返回函子包含的值。chain方法包装了map和join方法。实现 12345678910111213141516171819202122232425class Maybe &#123; constructor(value)&#123; this.value=value &#125; static of(value)&#123; return new Maybe(value) &#125; isNothing()&#123; return this.value===null || this.value===undefined &#125; join()&#123; return this.isNothing()?Maybe.of(null):this.value &#125; chain(fn)&#123; return this.map(fn).join() &#125; map(fn)&#123; return this.isNothing()?Maybe.of(null):Maybe.of(fn(this.value)) &#125;&#125; 使用（书上的示例太复杂，写个简单的） 1234567891011121314151617181920212223242526272829303132333435363738394041let bro=Maybe.of(&#123; name:'xhb', age:5&#125;)//我们来模仿一个场景！首先我们给小熊加一岁。let newBro=bro.map(bear=&gt;&#123; return &#123; ...bear, age:bear.age+1 &#125;&#125;)//我们继续处理小熊。//为了方便，我们直接输出小熊。newBro.map(bear=&gt;&#123; console.log(bear)&#125;)//天啊！这样太麻烦了。为了输出小熊我们不得不调用map函数。//关键是，此刻我们关心的是bear，而不是包装了bear的Maybe//可以这样let bigBear=bro.map(bear=&gt;&#123; return &#123; ...bear, age:bear.age+2 &#125;&#125;).join()console.log(bigBear)//顺利取出了结果！//每次都要写map和join，不如封装到一起let biggerBear=bro.chain(bear=&gt;&#123; return &#123; ...bear, age:bear.age+3 &#125;&#125;)console.log(biggerBear)//真好","categories":[{"name":"编程范式","slug":"编程范式","permalink":"https://walterbright.cc/categories/编程范式/"},{"name":"函数式编程","slug":"编程范式/函数式编程","permalink":"https://walterbright.cc/categories/编程范式/函数式编程/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://walterbright.cc/tags/函数式编程/"},{"name":"入门","slug":"入门","permalink":"https://walterbright.cc/tags/入门/"}]}]}